"use server";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { prisma } from "@/lib/db";
import { ocr } from "@/generated/prisma";
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

const PROMPT = `
Image Data Extraction Prompt

You are given three images.

Props to extract:
- weight (Int)
- vehicle_number (String)
- address (String)
- map_url (Google Maps URL)
- latitude (float)
- longitude (float)
- date (DateTime)

Example JSON output:

{
  "weight": 1500,
  "vehicle_number": "RJ-20GC-4556",
  "address": "1234 Main St, Cityville, Country",
  "map_url": "https://maps.google.com/?q=12.345678,-98.765432",
  "latitude": 12.34567,
  "longitude": -98.76543,
  "date": "2025-04-25T15:30:00Z"
}

Return only JSON.
`;
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
export type ExtractDataJsonType = {
  weight: number;
  vehicle_number: string;
  address: string;
  map_url: string;
  latitude: number;
  longitude: number;
  date: Date;
};
export const getFilePart = async (file: File) => ({
  inlineData: {
    mimeType: file.type,
    data: Buffer.from(await file.arrayBuffer()).toString("base64"),
  },
});
export const extractData = async (
  filePart: any,
  maxRetries = 3
): Promise<ExtractDataJsonType> => {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const result = await model.generateContent({
        contents: [
          {
            role: "user",
            parts: [{ text: PROMPT }, filePart],
          },
        ],
      });

      const jsonText = await result.response.text();
      const jsonString = jsonText.replace(/^```json\s*|\s*```$/g, "");
      console.log(`Extracted JSON (attempt ${attempt + 1}):`, jsonString);

      return JSON.parse(jsonString);
    } catch (error) {
      console.error(`Attempt ${attempt + 1} failed:`, error);
      attempt++;

      // Optional: wait before retrying
      await new Promise((res) => setTimeout(res, 500 * attempt));
    }
  }
  throw new Error("Failed to extract data from image after multiple attempts.");
};

export async function extractFromImages(formData: FormData) {
  const netFile = formData.get("net_weight") as File;
  const grossFile = formData.get("gross_weight") as File;
  const bufferFile = formData.get("buffer") as File;

  if (!netFile || !grossFile || !bufferFile) {
    throw new Error("All three files are required.");
  }

  const netPart = await getFilePart(netFile);
  const grossPart = await getFilePart(grossFile);
  const bufferPart = await getFilePart(bufferFile);

  const netData = await extractData(netPart);
  const grossData = await extractData(grossPart);
  const bufferData = await extractData(bufferPart);

  // Compare vehicle numbers from each image
  const netVehicleNumber = netData.vehicle_number;
  const grossVehicleNumber = grossData.vehicle_number;
  const bufferVehicleNumber = bufferData.vehicle_number;

  if (
    netVehicleNumber === grossVehicleNumber &&
    grossVehicleNumber === bufferVehicleNumber
  ) {
    // Vehicle numbers match, insert data into Prisma
    // const createdData = addOCRData()
    // // Return the data inserted
    // return createdData;
  } else {
    // Vehicle numbers do not match
    throw new Error("Vehicle numbers do not match between the three images.");
  }
}

export async function addOCRData(data: ocr) {
  try {
    return await prisma.ocr.create({
      data: { ...data, id: undefined },
    });
  } catch (error) {
    return Error("error");
  }
}

const E_WAYBILL_PROMPT = `
**E-Way Bill Number Extraction Prompt (For PDF)**

You are provided with a PDF document that contains logistics or shipment information.

**Your task is:**

* Extract the **E-Way Bill Number** from the document.
* The E-Way Bill Number is a **12-digit numeric value**.
* It is often labeled as:

  * \eWay Bill No:\
  * \E-Way Bill No:\
  * or appears near the phrase “Generated Date” or “Generated By”.
* Return **only** the 12-digit number(s).
* If multiple E-Way Bill Numbers are present, return them in a list.

**Example Output:**

\\\
691863991440
\\\



Do not include any explanation, headers, or extra formatting—only return the number(s).

`;

export const extractEWayBill = async (
  filePart: any,
  maxRetries = 3
): Promise<Number> => {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const result = await model.generateContent({
        contents: [
          {
            role: "user",
            parts: [{ text: E_WAYBILL_PROMPT }, filePart],
          },
        ],
      });

      const jsonText = await result.response.text();
      const jsonString = jsonText.replace(/^```json\s*|\s*```$/g, "");
      console.log(`Extracted JSON (attempt ${attempt + 1}):`, jsonString);

      return Number(jsonString);
    } catch (error) {
      console.error(`Attempt ${attempt + 1} failed:`, error);
      attempt++;

      // Optional: wait before retrying
      await new Promise((res) => setTimeout(res, 500 * attempt));
    }
  }
  throw new Error("Failed to extract data from image after multiple attempts.");
};

const Compare_PROMPT = `
Extract the following information from each uploaded PDF file **strictly following the format and rules below**.



### **Required Fields (return in JSON):**
\`\`\`json
{
  "vehicle_number": "UP45AT9123",
  "date": "14-05-2025",
  "net_weight": "1240.5 kg"
}
\`\`\`

---

### **Field Rules:**

* **\`vehicle_number\`**: Extract the full vehicle number exactly as it appears (e.g., \`"UP45AT9123"\`). If missing, return \`null\`.

* **\`date\`**: Extract the date in **DD-MM-YYYY** format (e.g., \`"14-05-2025"\`). If in another format, convert it. If unrecognizable, return \`null\`.

* **\`net_weight\`**:

  * Extract the weight value as a **number followed by its unit** (e.g., \`"1240.5 kg"\`).
  * **Remove any trailing \`.00\`** from the number (e.g., convert \`"39330.00"\` → \`"39330"\`).
  * Preserve the original **unit** use only "kg".
  * If the weight is not found, return \`null\`.



### **Output Requirements:**

* Return a **JSON object**.
* The keys \`vehicle_number\`, \`date\`, and \`net_weight\` **must always be present**.
* Use \`null\` if any value is missing.
* Do not include any additional fields.



### **Example Outputs:**

\`\`\`json
{
  "vehicle_number": "UP45AT9123",
  "date": "14-05-2025",
  "net_weight": "39330 KGS"
}
\`\`\`

\`\`\`json
{
  "vehicle_number": null,
  "date": "12-04-2025",
  "net_weight": "5.2 MT"
}
\`\`\`


`;

type ExtractDataFORComparJsonType = {
  vehicle_number: string;
  date: string;
  net_weight: string;
};
export const ExtractDataFORCompar = async (
  filePart: any,
  maxRetries = 3
): Promise<ExtractDataFORComparJsonType> => {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const result = await model.generateContent({
        contents: [
          {
            role: "user",
            parts: [{ text: Compare_PROMPT }, filePart],
          },
        ],
      });

      const jsonText = await result.response.text();
      const jsonString = jsonText.replace(/^```json\s*|\s*```$/g, "");
      console.log(`Extracted JSON (attempt ${attempt + 1}):`, jsonString);

      return JSON.parse(jsonString);
    } catch (error) {
      console.error(`Attempt ${attempt + 1} failed:`, error);
      attempt++;

      // Optional: wait before retrying
      await new Promise((res) => setTimeout(res, 500 * attempt));
    }
  }
  throw new Error("Failed to extract data from image after multiple attempts.");
};

export async function UpdateOCRData(id: number, data: Partial<ocr>) {
  try {
    return await prisma.ocr.update({
      where: { id },
      data,
    });
  } catch (error) {
    return Error("error");
  }
}

export async function getAllOcr() {
  return await prisma.ocr.findMany({
    take: 10,
    orderBy: {
      created_at: "desc",
    },
  });
}

export async function getOcr(id: number) {
  return await prisma.ocr.findUnique({
    where: {
      id,
    },
  });
}

export async function ocrCount() {
  return await prisma.ocr.count();
}
